<section data-transition="convex">
    <section data-background="images/list-shopping-list.jpeg">
        <h2 class="box-shadow-black">¿Qué es?</h2>
    </section>

    <section>
        <p>Colección de <span class="blue">elementos homogéneos</span></p>
        <p>Los elementos tienen posisiciones asignadas (hay un orden)</p>
        <p>Puede haber elementos repetidos</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h4>Lista enlazada (simple)</h4>
        <img src="slides/tad/lista-simple.dot.png" />
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h4>Lista circular (simple)</h4>
        <img src="slides/tad/lista-circular.dot.png" />
    </section>

    <section data-markdown>
        <script type="text/template">
Cada elemento de la lista almacena **un dato** y **un puntero** al elemento siguiente

```cpp[7-8]
#include <memory>
#include <iostream>
    
class Element {
    public:
        // Members
        std::string dato;
        std::shared_ptr<Element> next = nullptr;
    public:
        // Constructor 
        Element(const std::string& dato_) : dato{dato_} {};

        // Other methods
        bool is_last_element() { 
            return next == nullptr; 
        }
};
``` 

*Vamos a utilizar clases por uniformidad con otras asignaturas, pero igualmente podríamos usar 'struct'.  <!-- .element: class="footnote" -->

        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Una lista es una colección de elementos...

```cpp
// A collection of elements
std::shared_ptr<Element> e1 = std::make_shared<Element>(Element{"lechugas"});
std::shared_ptr<Element> e2 = std::make_shared<Element>(Element{"tomates"});
std::shared_ptr<Element> e3 = std::make_shared<Element>(Element{"pescado"});
// ... more elements
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
... en un orden determinado

```cpp
// e1 -> e2 -> e3 -> nullptr
e1->next = e2;
e2->next = e3;
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
La lista la referenciamos con el **puntero al primer elemento**

```cpp
// Pointer to the first element
std::shared_ptr<Element> my_list = e1;
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp
#include <memory>
#include <iostream>
    
class Element {
    public:
        // Members
        std::string dato;
        std::shared_ptr<Element> next = nullptr;
    public:
        // Constructor
        Element(const std::string& dato_) : dato{dato_} {};

        // Other methods
        bool is_last_element() { 
            return next == nullptr; 
        }
};

int main() {
    // Tenemos elementos
    std::shared_ptr<Element> e1 = std::make_shared<Element>(Element{"elem1"});
    std::shared_ptr<Element> e2 = std::make_shared<Element>(Element{"elem2"});
    std::shared_ptr<Element> e3 = std::make_shared<Element>(Element{"elem3"});

    // Los podemos poner en "orden" (uno detrás de otro)
    e1->next = e2;
    e2->next = e3;

    // La lista la representamos por el primer elemento
    std::shared_ptr<Element> lista = e1;
    
    // Los podemos imprimir, del primero al último:
    std::shared_ptr<Element> iterator = lista;  // primer elemento
    while (iterator != nullptr) {
        std::cout << iterator->dato << std::endl;
        iterator = iterator->next;  // el iterador apunta al siguiente elemento
    }
}
```
        </script>
    </section>

    <section>
        <h4>Limitación de una lista simple</h4>
        <ul>
            <li>Sólo puedo ir hacia adelante (puntero a <code>next</code>)</li>
        </ul>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h4>Lista doblemente enlazada</h4>
        <img src="slides/tad/lista-doble.dot.png" />
        <div class="footnote"><sup>*</sup>Por supuesto, también puede hacerse circular.</div>
    </section>

    <section data-markdown>
        <script type="text/template">
Cada elemento contiene **un dato**, **un puntero** al elemento siguiente y **otro puntero** al anterior.

```cpp[9]
#include <memory>
#include <iostream>
    
class Element {
    public:
        // Members
        std::string dato;
        std::shared_ptr<Element> next = nullptr;
        std::shared_ptr<Element> prev = nullptr;
    public:
        // Constructor 
        Element(const std::string& dato_) : dato{dato_} {};
};
``` 
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Representación</h2>
    </section>
    <section data-background-color="rgb(255, 255, 255)">
        <p>Por simplificar, representamos únicamente los datos en los elementos y las flechas representan los punteros.
        </p>
        <img src="slides/tad/lista-example.dot.png" />
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>El puntero a <code>nullptr</code> no se representa.</p>
        <img src="slides/tad/lista-example2.dot.png" />
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Ej.: lista doblemente enlazada.</p>
        <img src="slides/tad/lista-example3.dot.png" />
    </section>

</section>

<section data-transition="convex">
    <section>
        <h2>Iterar una lista</h2>
    </section>

    <section data-markdown>
        <script type="text/template">
Iterar una lista de elementos e imprimir sus datos

```cpp[4-10]
#include <memory>
#include <iostream>

///hide
class Element {
    public:
        // Members
        std::string dato;
        std::shared_ptr<Element> next = nullptr;
    public:
        // Constructor 
        Element(const std::string& dato_) : dato{dato_} {};
};
///unhide
void print_list(std::shared_ptr<Element> lista) {
    std::shared_ptr<Element> iterator = lista;
    while (iterator != nullptr) {
        std::cout << iterator->dato << std::endl;
        iterator = iterator->next;
    }
}

int main() {
    // Tenemos elementos
    std::shared_ptr<Element> e1 = std::make_shared<Element>(Element{"elem1"});
    std::shared_ptr<Element> e2 = std::make_shared<Element>(Element{"elem2"});
    std::shared_ptr<Element> e3 = std::make_shared<Element>(Element{"elem3"});

    // Los podemos poner en "orden" (uno detrás de otro)
    e1->next = e2;
    e2->next = e3;

    // La lista la representamos por el primer elemento
    std::shared_ptr<Element> lista = e1;
    print_list(lista);
}
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
💻  Imprimir la posición y el dato de cada elemento de una lista

```cpp
///hide
#include <memory>
#include <iostream>

class Element {
    public:
        // Members
        std::string dato;
        std::shared_ptr<Element> next = nullptr;
    public:
        // Constructor 
        Element(const std::string& dato_) : dato{dato_} {};
};
///unhide
/* This function prints the index and the data of every
   element in the list. For a list like {elem1, elem2, elem3}
   it will print:

   0: elem1
   1: elem2
   2: elem3
*/
void print_list(std::shared_ptr<Element> lista);
///hide
void print_list(std::shared_ptr<Element> lista) {
    std::shared_ptr<Element> iterator = lista;
    int idx = 0;
    while (iterator != nullptr) {
        std::cout << idx << ": " << iterator->dato << std::endl;
        iterator = iterator->next;
        idx++;
    }
}

int main() {
    // Tenemos elementos
    std::shared_ptr<Element> e1 = std::make_shared<Element>(Element{"elem1"});
    std::shared_ptr<Element> e2 = std::make_shared<Element>(Element{"elem2"});
    std::shared_ptr<Element> e3 = std::make_shared<Element>(Element{"elem3"});

    // Los podemos poner en "orden" (uno detrás de otro)
    e1->next = e2;
    e2->next = e3;

    // La lista la representamos por el primer elemento
    std::shared_ptr<Element> lista = e1;
    print_list(lista);
}
///unhide
``` 
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Tamaño de una lista</h2>
    </section>

    <section>
        <h4 class="caps-preserve"><code>size</code></h4>
        <p>Tamaño de la lista</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Tamaño de una lista (iterativo)

```cpp
int size(std::shared_ptr<Element> lista) {
    int size = 0;
    std::shared_ptr<Element> iterator = lista; // first element
    while (iterator != nullptr) {
        size += 1;
        iterator = iterator->next;
    }
    return size;
}
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Tamaño de una lista (recursivo)

```cpp
int size(std::shared_ptr<Element> lista) {
    if (lista == nullptr) {
        return 0;
    }
    return 1 + size(lista->next);
}
``` 
        </script>
    </section>

    <section>
        <h4 class="caps-preserve"><code>empty</code></h4>
        <p>Comprobar lista vacía</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Comprobar si una lista está vacía

```cpp
int empty(std::shared_ptr<Element> lista) {
    return (lista == nullptr);
}
```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Comprobar si una lista está vacía...

...usando otras funciones 🤔

```cpp
int empty(std::shared_ptr<Element> lista) {
    return size(lista) == 0;
}
```
<!-- .element: class="fragment" -->
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Acceso</h2>
    </section>

    <section>
        <h4 class="caps-preserve"><code>at</code></h4>
        <p>Devuelve el elemento en una posición</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Acceder al elemento que ocupa la posición `i`. Devuelve el elemenot en dicha posición o `nullptr`.

```cpp
// Returns the element from 'lista' at position 'pos'
std::shared_ptr<Element> at(std::shared_ptr<Element> lista, 
                            int pos) {
    int idx = 0;
    std::shared_ptr<Element> iterator = lista;
    while (iterator != nullptr) {
        if (idx == pos) {
            return iterator;
        }
        iterator = iterator->next;
        idx++;
    }
    return nullptr;
}
```
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Inserción</h2>
    </section>

    <section>
        <h4 class="caps-preserve"><code>push_back</code></h4>
        <p>Insertar elemento al final</p>
    </section>

    <section>
        <h4 class="caps-preserve"><code>push_front</code></h4>
        <p>Insertar elemento al principio</p>
    </section>

    <section>
        <h4 class="caps-preserve"><code>insert</code></h4>
        <p>Insertar elemento intermedio</p>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Borrado</h2>
    </section>

    <section>
        <h4 class="caps-preserve"><code>erase</code></h4>
        <p>Borrar elemento en una posición</p>
    </section>

    <section>
        <h4 class="caps-preserve"><code>pop_back</code></h4>
        <p>Elimina (y devuelve) el último elemento</p>
    </section>

    <section>
        <h4 class="caps-preserve"><code>pop_front</code></h4>
        <p>Elimina (y devuelve) el primer elemento</p>
    </section>

    <section>
        <h4 class="caps-preserve"><code>clear</code></h4>
        <p>Elimina todos los elementos</p>
    </section>

</section>

<section data-transition="convex">
    <section>
        <h2>Otras operaciones</h2>
    </section>

    <section>
        <h4 class="caps-preserve"><code>search</code></h4>
        <p>Búsqueda de un elemento</p>
    </section>

    <section>
        <h4 class="caps-preserve"><code>distance</code></h4>
        <p>Distancia entre dos elementos</p>
    </section>

    <section>
        <h4 class="caps-preserve"><code>swap</code></h4>
        <p>Intercambiar dos elementos</p>
    </section>

    <section>
        <h4 class="caps-preserve"><code>slice</code></h4>
        <p>Devuelve un _trozo_ de una lista</p>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Ejercicios propuestos</h2>
    </section>
</section>
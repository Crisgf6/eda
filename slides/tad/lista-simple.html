<section data-transition="convex">
    <section data-background="images/list-shopping-list.jpeg">
        <h2 class="box-shadow-black">¬øQu√© es?</h2>
    </section>

    <section>
        <p>Colecci√≥n de <span class="blue">elementos homog√©neos</span></p>
        <p>Los elementos tienen posisiciones asignadas (hay un orden)</p>
        <p>Puede haber elementos repetidos</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h4>Lista enlazada (simple)</h4>
        <img src="slides/tad/lista-simple.dot.png" />
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h4>Lista circular (simple)</h4>
        <img src="slides/tad/lista-circular.dot.png" />
    </section>

    <section data-markdown>
        <script type="text/template">
Cada elemento de la lista almacena **un dato** y **un puntero** al elemento siguiente

```cpp[7-8]
#include <memory>
#include <iostream>
    
class Element {
    public:
        // Members
        std::string dato;
        std::shared_ptr<Element> next = nullptr;
    public:
        // Constructor 
        Element(const std::string& dato_) : dato{dato_} {};

        // Other methods
        bool is_last_element() { 
            return next == nullptr; 
        }
};
``` 

*Vamos a utilizar clases por uniformidad con otras asignaturas, pero igualmente podr√≠amos usar 'struct'.  <!-- .element: class="footnote" -->

        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Una lista es una colecci√≥n de elementos...

```cpp
// A collection of elements
std::shared_ptr<Element> e1 = std::make_shared<Element>(Element{"lechugas"});
std::shared_ptr<Element> e2 = std::make_shared<Element>(Element{"tomates"});
std::shared_ptr<Element> e3 = std::make_shared<Element>(Element{"pescado"});
// ... more elements
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
... en un orden determinado

```cpp
// e1 -> e2 -> e3 -> nullptr
e1->next = e2;
e2->next = e3;
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
La lista la referenciamos con el **puntero al primer elemento**

```cpp
// Pointer to the first element
std::shared_ptr<Element> my_list = e1;
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp
#include <memory>
#include <iostream>
    
class Element {
    public:
        // Members
        std::string dato;
        std::shared_ptr<Element> next = nullptr;
    public:
        // Constructor
        Element(const std::string& dato_) : dato{dato_} {};

        // Other methods
        bool is_last_element() { 
            return next == nullptr; 
        }
};

int main() {
    // Tenemos elementos
    std::shared_ptr<Element> e1 = std::make_shared<Element>(Element{"elem1"});
    std::shared_ptr<Element> e2 = std::make_shared<Element>(Element{"elem2"});
    std::shared_ptr<Element> e3 = std::make_shared<Element>(Element{"elem3"});

    // Los podemos poner en "orden" (uno detr√°s de otro)
    e1->next = e2;
    e2->next = e3;

    // La lista la representamos por el primer elemento
    std::shared_ptr<Element> lista = e1;
    
    // Los podemos imprimir, del primero al √∫ltimo:
    std::shared_ptr<Element> iterator = lista;  // primer elemento
    while (iterator != nullptr) {
        std::cout << iterator->dato << std::endl;
        iterator = iterator->next;  // el iterador apunta al siguiente elemento
    }
}
```
        </script>
    </section>

    <section>
        <h4>Limitaci√≥n de una lista simple</h4>
        <ul>
            <li>S√≥lo puedo ir hacia adelante (puntero a <code>next</code>)</li>
        </ul>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h4>Lista doblemente enlazada</h4>
        <img src="slides/tad/lista-doble.dot.png" />
        <div class="footnote"><sup>*</sup>Por supuesto, tambi√©n puede hacerse circular.</div>
    </section>

    <section data-markdown>
        <script type="text/template">
Cada elemento contiene **un dato**, **un puntero** al elemento siguiente y **otro puntero** al anterior.

```cpp[9]
#include <memory>
#include <iostream>
    
class Element {
    public:
        // Members
        std::string dato;
        std::shared_ptr<Element> next = nullptr;
        std::shared_ptr<Element> prev = nullptr;
    public:
        // Constructor 
        Element(const std::string& dato_) : dato{dato_} {};
};
``` 
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Representaci√≥n</h2>
    </section>
    <section data-background-color="rgb(255, 255, 255)">
        <p>Por simplificar, representamos √∫nicamente los datos en los elementos y las flechas representan los punteros.
        </p>
        <img src="slides/tad/lista-example.dot.png" />
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>El puntero a <code>nullptr</code> no se representa.</p>
        <img src="slides/tad/lista-example2.dot.png" />
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Ej.: lista doblemente enlazada.</p>
        <img src="slides/tad/lista-example3.dot.png" />
    </section>

</section>

<section data-transition="convex">
    <section>
        <h2>Iterar una lista</h2>
    </section>

    <section data-markdown>
        <script type="text/template">
Iterar una lista de elementos e imprimir sus datos

```cpp[4-10]
#include <memory>
#include <iostream>

///hide
class Element {
    public:
        // Members
        std::string dato;
        std::shared_ptr<Element> next = nullptr;
    public:
        // Constructor 
        Element(const std::string& dato_) : dato{dato_} {};
};
///unhide
void print_list(std::shared_ptr<Element> lista) {
    std::shared_ptr<Element> iterator = lista;
    while (iterator != nullptr) {
        std::cout << iterator->dato << std::endl;
        iterator = iterator->next;
    }
}

int main() {
    // Tenemos elementos
    std::shared_ptr<Element> e1 = std::make_shared<Element>(Element{"elem1"});
    std::shared_ptr<Element> e2 = std::make_shared<Element>(Element{"elem2"});
    std::shared_ptr<Element> e3 = std::make_shared<Element>(Element{"elem3"});

    // Los podemos poner en "orden" (uno detr√°s de otro)
    e1->next = e2;
    e2->next = e3;

    // La lista la representamos por el primer elemento
    std::shared_ptr<Element> lista = e1;
    print_list(lista);
}
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
üíª  Imprimir la posici√≥n y el dato de cada elemento de una lista

```cpp
///hide
#include <memory>
#include <iostream>

class Element {
    public:
        // Members
        std::string dato;
        std::shared_ptr<Element> next = nullptr;
    public:
        // Constructor 
        Element(const std::string& dato_) : dato{dato_} {};
};
///unhide
/* This function prints the index and the data of every
   element in the list. For a list like {elem1, elem2, elem3}
   it will print:

   0: elem1
   1: elem2
   2: elem3
*/
void print_list(std::shared_ptr<Element> lista);
///hide
void print_list(std::shared_ptr<Element> lista) {
    std::shared_ptr<Element> iterator = lista;
    int idx = 0;
    while (iterator != nullptr) {
        std::cout << idx << ": " << iterator->dato << std::endl;
        iterator = iterator->next;
        idx++;
    }
}

int main() {
    // Tenemos elementos
    std::shared_ptr<Element> e1 = std::make_shared<Element>(Element{"elem1"});
    std::shared_ptr<Element> e2 = std::make_shared<Element>(Element{"elem2"});
    std::shared_ptr<Element> e3 = std::make_shared<Element>(Element{"elem3"});

    // Los podemos poner en "orden" (uno detr√°s de otro)
    e1->next = e2;
    e2->next = e3;

    // La lista la representamos por el primer elemento
    std::shared_ptr<Element> lista = e1;
    print_list(lista);
}
///unhide
``` 
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Tama√±o de una lista</h2>
    </section>

    <section>
        <h4 class="caps-preserve"><code>size</code></h4>
        <p>Tama√±o de la lista</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Tama√±o de una lista (iterativo)

```cpp
int size(std::shared_ptr<Element> lista) {
    int size = 0;
    std::shared_ptr<Element> iterator = lista; // first element
    while (iterator != nullptr) {
        size += 1;
        iterator = iterator->next;
    }
    return size;
}
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Tama√±o de una lista (recursivo)

```cpp
int size(std::shared_ptr<Element> lista) {
    if (lista == nullptr) {
        return 0;
    }
    return 1 + size(lista->next);
}
``` 
        </script>
    </section>

    <section>
        <h4 class="caps-preserve"><code>empty</code></h4>
        <p>Comprobar lista vac√≠a</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Comprobar si una lista est√° vac√≠a

```cpp
bool empty(std::shared_ptr<Element> lista) {
    return (lista == nullptr);
}
```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Comprobar si una lista est√° vac√≠a...

...usando otras funciones ü§î

```cpp
bool empty(std::shared_ptr<Element> lista) {
    return size(lista) == 0;
}
```
<!-- .element: class="fragment" -->
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Acceso</h2>
    </section>

    <section>
        <h4 class="caps-preserve"><code>at</code></h4>
        <p>Devuelve el elemento en una posici√≥n</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Acceder al elemento que ocupa la posici√≥n `i`-√©sima. Devuelve el elemento en dicha posici√≥n o `nullptr`.

```cpp
// Returns the element from 'lista' at position 'pos'
std::shared_ptr<Element> at(std::shared_ptr<Element> lista, 
                            int pos) {
    int idx = 0;
    std::shared_ptr<Element> iterator = lista;
    while (iterator != nullptr) {
        if (idx == pos) {
            return iterator;
        }
        iterator = iterator->next;
        idx++;
    }
    return nullptr;
}
```
        </script>
    </section>

    <section>
        <h4 class="caps-preserve"><code>front</code></h4>
        <p>Devuelve el primer elemento</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Devuelve el primer elemento de la lista (o `nullptr` si est√° vac√≠a).

```cpp
// Returns first element from 'lista'
std::shared_ptr<Element> front(std::shared_ptr<Element> lista) {
    return at(lista, 0);
}
```
        </script>
    </section>

    <section>
        <h4 class="caps-preserve"><code>back</code></h4>
        <p>Devuelve el √∫ltimo elemento de la lista</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Devuelve el √∫ltimo elemento de la lista (o `nullptr` si est√° vac√≠a).

```cpp
// Returns last element from 'lista'
std::shared_ptr<Element> back(std::shared_ptr<Element> lista) {
    std::shared_ptr<Element> iterator = lista;
    while (iterator != nullptr) {
        if (iterator->next == nullptr) {
            return iterator;
        }
        iterator = iterator->next;
    }
    return iterator;  // Note that we are returning the iterator instead of 'nullptr' value
}
```

ü§î ü§î  Podr√≠amos implementarlo como 'return at(lista, size(lista)-1)', pero recorrer√≠amos la lista dos veces.  <!-- .element: class="footnote" -->
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Inserci√≥n</h2>
    </section>

    <section>
        <h4 class="caps-preserve"><code>push_back</code></h4>
        <p>Insertar elemento al final</p>
    </section>

    <section>
        <p>Insertar elemento al final</p>
        <img src="slides/tad/lista-push_back.dot.png"/>
    </section>

    <section data-markdown>
        <script type="text/template">
Inserta un elemento al final de la lista.

```cpp
// Inserts element 'elem' as the last element of the list
void push_back(std::shared_ptr<Element>& lista,  // Note the reference
               std::shared_ptr<Element> elem) {
    if (empty(lista)) {
        lista = elem;  // Now it is the only element in the list
    }
    else {
        std::shared_ptr<Element> latest = back(lista);
        latest->next = elem;
    }
}
```
        </script>
    </section>

    <section>
        <h4 class="caps-preserve"><code>push_front</code></h4>
        <p>Insertar elemento al principio</p>
    </section>

    <section>
        <p>Insertar elemento al principio</p>
        <img src="slides/tad/lista-push_front.dot.png"/>
        <img class="fragment" data-fragment-index="1" src="slides/tad/lista-push_front2.dot.png"/>
        <p class="fragment" data-fragment-index="1">¬°Necesitamos modificar el puntero de <code>lista</code>! üëÄ</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Inserta un elemento al principio de la lista (usando referencia).

```cpp
// Inserts element 'elem' as the first element of the list
void push_front(std::shared_ptr<Element>& lista, // Note the reference
                std::shared_ptr<Element> elem) {
    if (empty(lista)) {
        lista = elem;  // Now it is the only element in the list
    }
    else {
        elem->next = lista;
        lista = elem;
    }
}
```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Inserta un elemento al principio de la lista (usando valor de retorno).

```cpp
// Inserts element 'elem' as the first element of the list, and returns the new list
std::shared_ptr<Element> push_front(std::shared_ptr<Element> lista,
                                    std::shared_ptr<Element> elem) {
    if (empty(lista)) {
        lista = elem;  // Now it is the only element in the list
    }
    else {
        elem->next = lista;
        lista = elem;
    }
    return lista;
}
```
        </script>
    </section>

    <section>
        <h4 class="caps-preserve"><code>insert</code></h4>
        <p>Insertar elemento intermedio</p>
    </section>

    <section>
        <p>Insertar elemento intermedio</p>
        <img src="slides/tad/lista-insert.dot.png"/>
        <img class="fragment" data-fragment-index="1" src="slides/tad/lista-insert2.dot.png"/>
    </section>

    <section data-markdown>
        <script type="text/template">
Inserta un elemento intermedio (paso por referencia*).

```cpp
// Inserts 'elem' in the position indicated by 'pos'.
// Return value indicates whether the operation was completed
// successfully or not
bool insert(std::shared_ptr<Element>& lista, // Note the reference
            std::shared_ptr<Element> elem,
            int pos) {
    if (pos == 0) {
        push_front(lista, elem);
        return true;
    }
    else if (pos > size(lista)) {
        // List is not so long
        return false;
    }
    else {
        std::shared_ptr<Element> previous = at(lista, pos - 1);
        elem->next = previous->next;
        previous->next = elem;
        return true;
    }
}
```

ü§î ü§î  *Podr√≠an pedirme insertarlo el primero, as√≠ que sigue pasando lista por referencia.  <!-- .element: class="footnote" -->
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Borrado</h2>
    </section>

    <section>
        <h4 class="caps-preserve"><code>pop_back</code></h4>
        <p>Elimina (y devuelve) el √∫ltimo elemento</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Elimina (y devuelve) el √∫ltimo elemento.

```cpp
// Removes (and returns) the last element from the list
std::shared_ptr<Element> pop_back(std::shared_ptr<Element>& lista) {
    int lista_size = size(lista);
    if (lista_size == 0) {
        return nullptr;
    }
    else if (lista_size == 1) {
        std::shared_ptr<Element> ret = lista;
        lista = nullptr;
        return ret;
    }
    else {
        // Get the second-to-last element (pen√∫ltimo elemento)
        std::shared_ptr<Element> previous = at(lista, lista_size - 2);
        std::shared_ptr<Element> ret = previous->next;
        previous->next = nullptr;
        return ret;
    }
}
```
        </script>
    </section>

    <section>
        <h4 class="caps-preserve"><code>pop_front</code></h4>
        <p>Elimina (y devuelve) el primer elemento</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Elimina (y devuelve) el primer elemento.

```cpp
// Removes (and returns) the first element from the list
std::shared_ptr<Element> pop_front(std::shared_ptr<Element>& lista) {
    if (empty(lista)) {
        return nullptr;
    }
    else {
        std::shared_ptr<Element> ret = lista;
        lista = lista->next;
        return ret;
    }
}
```
        </script>
    </section>

    <section>
        <h4 class="caps-preserve"><code>clear</code></h4>
        <p>Elimina todos los elementos</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Elimina todos los elementos.

```cpp
// Remove all elements from the list
void clear(std::shared_ptr<Element>& lista) {
    lista = nullptr;
}
```
        </script>
    </section>

    <section>
        <h4 class="caps-preserve"><code>erase</code></h4>
        <p>Borrar elemento en una posici√≥n</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Elimina el elemento de la posici√≥n indicada. Devuelve si la operaci√≥n ha tenido √©xito o no.

```cpp
// Remove all elements from the list
bool erase(std::shared_ptr<Element>& lista, int pos) {
    int lista_size = size(lista);
    if (pos >= lista_size) {
        return false;
    }

    if (pos == 0) {
        auto front_element = pop_front(lista);  // Removes and returns first element
        return true;
    }
    else {
        std::shared_ptr<Element> previous = at(lista, pos-1);
        previous->next = previous->next->next;
        return true;
    }
}
```
        </script>
    </section>

</section>

<section data-transition="convex">
    <section>
        <h2>Otras operaciones</h2>
    </section>

    <section>
        <h4 class="caps-preserve"><code>distance</code></h4>
        <p>Distancia entre dos elementos</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Dados dos elementos de la lista (sus punteros), indicar la distancia entre ellos. La distancia se mide como el n√∫mero de saltos.

```cpp
// Returns the number of hops between two (pointers to) elements in the list
int distance(std::shared_ptr<Element> lista, 
             std::shared_ptr<Element> elem1, 
             std::shared_ptr<Element> elem2) {
    std::shared_ptr<Element> iterator = lista;
    int distance = 0;
    bool first_found = 0;
    while (iterator != nullptr) {
        if (!first_found && iterator == elem1) {
            first_found = true;
        }
        if (first_found && iterator == elem2) {
            return distance;
        }
        if (first_found) {
            distance++;
        }
        iterator = iterator->next;
    }
    return -1; // Some of the elements was not found!
}
```
        </script>
    </section>

    <section>
        <h4 class="caps-preserve"><code>swap</code></h4>
        <p>Intercambiar dos elementos</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Intercambiar dos elementos dados por sus √≠ndices.

‚ùó Se trata de intercambiar los elementos (punteros), no de copiar los datos de uno en el otro.

```cpp
// Swap two elements inside the list. Assume pos2 > pos1
void swap(std::shared_ptr<Element>& lista, 
          int pos1, int pos2) {
    std::shared_ptr<Element> element2_prev = at(lista, pos2 - 1);
    std::shared_ptr<Element> element2 = element2_prev->next;
    std::shared_ptr<Element> element2_post = element2->next;

    if (pos1 == 0) {
        std::shared_ptr<Element> element1 = lista;

        lista = element2;
        element2_prev->next = element1;

        element2->next = element1->next;
        element1->next = element2_post;
    }
    else {
        std::shared_ptr<Element> element1_prev = at(lista, pos1 - 1);
        std::shared_ptr<Element> element1 = element1_prev->next;

        element1_prev->next = element2;
        element2_prev->next = element1;

        element2->next = element1->next;
        element1->next = element2_post;
    }
}
```
        </script>
    </section>

</section>


<section data-transition="convex">
    <section>
        <h2>Operaciones con los datos</h2>
    </section>

    <section>
        <p>‚ùó‚ùó‚ùó Hasta ahora s√≥lo hemos utilizado los punteros, no hemos utilizado los datos para nada ‚ùó‚ùó‚ùó</p>
        <p class="fragment">¬øFuncionar√°n as√≠ los contenedores gen√©ricos <code>std::list&lt;T&gt;</code>? *</p>
        <div class="footnote fragment"><sup>*</sup>Spoiler: s√≠, y lo ver√°s en asignaturas de programaci√≥n.</div>
    </section>

    <section>
        <h4 class="caps-preserve"><code>search</code></h4>
        <p>B√∫squeda de un elemento</p>
    </section>

    <section>
        <h4 class="caps-preserve"><code>sort</code></h4>
        <p>Ordenaci√≥n en base al valor de los elementos</p>
    </section>
</section>

<section>
    <h4 class="caps-preserve"><code>slice</code></h4>
    <p>Devuelve un _trozo_ de una lista</p>
</section>

<section data-transition="convex">
    <section>
        <h2>Ejercicios propuestos</h2>
    </section>
</section>